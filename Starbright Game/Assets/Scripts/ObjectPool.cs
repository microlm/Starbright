//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System.Collections.Generic;
using UnityEngine;
using System;

public class ObjectPool : MonoBehaviour
{
	public GameObject asteroidPrefab1;
	public GameObject asteroidPrefab2;
	public GameObject asteroidPrefab3;
	public GameObject asteroidPrefab4;
	public GameObject asteroidPrefab5;
	public GameObject farAsteroidPrefab1;
	public GameObject farAsteroidPrefab2;
	public GameObject farAsteroidPrefab3;
	public GameObject farAsteroidPrefab4;
	public GameObject farAsteroidPrefab5;
	public GameObject blackHolePrefab;


	private List<GameObject> pool;
	private List<Boolean> isFree;
	private List<GameObject> blackHolePool;
	private List<Boolean> isBlackHoleFree;
	private GameObject[] prefabs;
	private GameObject[] farPrefabs;

	void Awake()
	{
		pool = new List<GameObject>();
		isFree = new List<Boolean>();
		blackHolePool = new List<GameObject>();
		isBlackHoleFree = new List<Boolean>();
		prefabs = new GameObject[5] {asteroidPrefab1, asteroidPrefab2, asteroidPrefab3, asteroidPrefab4, asteroidPrefab5};
		farPrefabs = new GameObject[5] {farAsteroidPrefab1, farAsteroidPrefab2, farAsteroidPrefab3, farAsteroidPrefab4, farAsteroidPrefab5};
	}

	void Start()
	{
		// Don't put things here - other classes need to use this class during start, so things need to be set up using Awake()
	}

	void Update()
	{
		//Debug.Log(pool.Count);
	}

	public int addBody(float x, float y, float depth, float mass, bool isFar, bool isBlackHole)
	{
		if (!isBlackHole) 
		{
			int nextFree = 0;
			while (nextFree < isFree.Count && !(isFree[nextFree] || !pool[nextFree].activeSelf))
					nextFree++;
			if (nextFree == pool.Count) {
					GameObject asteroid;
					if (!isFar) {
							asteroid = (GameObject)Instantiate (pickAPrefab (prefabs), new Vector3 (x, y, depth), Quaternion.identity);
					} else {
							asteroid = (GameObject)Instantiate (pickAPrefab (farPrefabs), new Vector3 (x, y, depth), Quaternion.identity);
					}
					Body asteroidScript = asteroid.GetComponent<Body> ();
					asteroidScript.mass = mass;
					
					pool.Add (asteroid);
					isFree.Add (false);
					return nextFree;
			}
			GameObject a = pool [nextFree];
			a.rigidbody2D.transform.position = new Vector3 (x, y, depth);
			SpriteRenderer renderer;
			if (!isFar) {
					renderer = pickAPrefab (prefabs).GetComponent<SpriteRenderer> ();
			} else {
					renderer = pickAPrefab (farPrefabs).GetComponent<SpriteRenderer> ();
			}
			a.GetComponent<SpriteRenderer> ().sprite = renderer.sprite;
			Body aScript = a.GetComponent<Body> ();
			aScript.mass = mass;
			a.SetActive (true);
			isFree [nextFree] = false;
			return nextFree;
		}
		else
		{
			int nextBlackHoleFree = 0;
			while(nextBlackHoleFree < isBlackHoleFree.Count && !(isBlackHoleFree[nextBlackHoleFree] || !blackHolePool[nextBlackHoleFree].activeSelf)) nextBlackHoleFree++;
			if(nextBlackHoleFree == blackHolePool.Count)
			{
				GameObject blackHole;
				blackHole = (GameObject)Instantiate(blackHolePrefab, new Vector3(x, y, depth), Quaternion.identity);
				blackHolePool.Add(blackHole);
				isBlackHoleFree.Add(false);
				return (nextBlackHoleFree + 1) * -1;
			}
			GameObject b = blackHolePool[nextBlackHoleFree];
			b.transform.position = new Vector3(x, y, depth);
			b.SetActive(true);
			isBlackHoleFree[nextBlackHoleFree] = false;
			return (nextBlackHoleFree + 1) * -1;
		}
	}

	public GameObject getBody(int index)
	{
		if(index >= 0)
			return pool[index];
		else
			return blackHolePool[(index + 1) * -1];
	}

	public Vector3 removeBody(int index)
	{
		//Can't set a vector to null, and I can't get it to recognize tuples...I'm sorry for using a sentinel
		Vector3 pos = new Vector3(0,0,-1000);
		if(index >= 0)
		{
			if(!pool[index].activeSelf)
			{
				pos = pool[index].transform.position;
			}
			pool[index].SetActive(false);
			isFree[index] = true;
		}
		else
		{
			blackHolePool[(index + 1) * -1].SetActive(false);
			isBlackHoleFree[(index + 1) * -1] = true;
		}
		return pos;
	}

	public void drain()
	{
		for(int i = 0; i < pool.Count; i++) removeBody(i);
		for(int i = 0; i < blackHolePool.Count; i++) removeBody((i + 1) * -1);
	}

	private GameObject pickAPrefab(GameObject[] objs)
	{
		int num = objs.Length;
		int pick = Mathf.FloorToInt(UnityEngine.Random.Range (0, num));
		return objs[pick];
	}

	public void setPoolLayer(int layer)
	{
		for(int i = 0; i < pool.Count; i++) 
			pool[i].layer = layer;
		for(int i = 0; i < blackHolePool.Count; i++)
			blackHolePool[i].layer = layer;
	}

	public void setParent(GameObject parent)
	{
		for(int i = 0; i < pool.Count; i++) 
			pool[i].transform.parent = parent.transform;
		for(int i = 0; i < blackHolePool.Count; i++) 
			blackHolePool[i].transform.parent = parent.transform;
	}

	public void setEnableCollisions(bool enable)
	{
		for(int i = 0; i < pool.Count; i++)
			pool[i].rigidbody2D.collider2D.enabled = enable;
	}

	public void setEnabledChildren(bool enabled)
	{
		for (int i=0; i < pool.Count; i++)
		{
			foreach(Transform child in pool[i].transform)
			{
				child.gameObject.SetActive (enabled);
			}
		}
		for (int i=0; i < blackHolePool.Count; i++)
		{
			foreach(Transform child in blackHolePool[i].transform)
			{
				child.gameObject.SetActive (enabled);
			}
		}
	}

	public void setForegroundImage()
	{
		for(int i=0; i < pool.Count; i++)
		{
			string name = pool[i].name;
			int x = Int32.Parse(name[name.Length - 8] +"");
			pool[i].GetComponent<SpriteRenderer>().sprite = prefabs[x - 1].GetComponent<SpriteRenderer>().sprite;
		}
	}

	public void setBackgroundImage()
	{
		for(int i=0; i < pool.Count; i++)
		{
			string name = pool[i].name;
			int x = Int32.Parse(name[name.Length - 12] +"");
			
			pool[i].GetComponent<SpriteRenderer>().sprite = farPrefabs[x - 1].GetComponent<SpriteRenderer>().sprite;
		}
	}

	/*---------------------------------------------
	 * Used during layering up/down only! Removes
	 * objects which overlap with the player 
	 * character.
	 * --------------------------------------------*/
	public void removePCOverlap(Bounds pc)
	{
		for(int i = 0; i < pool.Count; i++)
		{
			if(circlesIntersect(pc, pool[i].GetComponent<SpriteRenderer>().bounds))
			{
				removeBody(i);
			}
		}
		for (int i = 0; i < blackHolePool.Count; i++)
		{
			if (circlesIntersect(pc, blackHolePool[i].GetComponent<CircleCollider2D>().bounds))
			{
				removeBody((i + 1) * -1);
			}
		}
	}

	bool circlesIntersect(Bounds a, Bounds b)
	{
		double distanceX = a.center.x - b.center.x;
		double distanceY = a.center.y - b.center.y;
		
		double magnitude = Math.Sqrt(distanceX * distanceX + distanceY * distanceY);
	
		return magnitude < a.extents.x + b.extents.x;
	}
}

